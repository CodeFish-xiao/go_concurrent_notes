#  Mutex：骇客编程，如何拓展额外功能？
前面我们搞了互斥锁 Mutex 的基本用法、实现原理以及易错场景，可以说是涵盖了互斥锁的方方面面。如果你能熟练掌握这些内容，那么，在大多数的开发场景中，你都可以得心应手。

但是，在一些特定的场景中，这些基础功能是不足以应对的。这个时候，我们就需要开发一些扩展功能了。

比如说，我们知道，如果互斥锁被某个 goroutine 获取了，而且还没有释放，那么，其他请求这把锁的 goroutine，就会阻塞等待，直到有机会获得这把锁。有时候阻塞并不是一个很好的主意，比如你请求锁更新一个计数器，如果获取不到锁的话没必要等待，大不了这次不更新，我下次更新就好了，如果阻塞的话会导致业务处理能力的下降。

再比如，如果我们要监控锁的竞争情况，一个监控指标就是，等待这把锁的 goroutine 数量。我们可以把这个指标推送到时间序列数据库中，再通过一些监控系统（比如 Grafana）展示出来。要知道，**锁是性能下降的“罪魁祸首”之一，所以，有效地降低锁的竞争，就能够很好地提高性能。因此，监控关键互斥锁上等待的 goroutine 的数量，是我们分析锁竞争的激烈程度的一个重要指标。**

其实吧，你要是把资源安排的妥妥当当，又要等待吗？还需要阻塞吗？顺畅的一痞性能不久高起来了吗？或者这个资源不行，我们换个资源，先做其它的，然后再等就行了呀。所以我们可以通过 Hacker 的方式，为 Mutex 增加一些额外的功能。包括实现 TryLock，获取等待者的数量等指标，以及实现一个线程安全的队列。

## TryLock 

我们可以为 Mutex 添加一个 TryLock 的方法，也就是尝试获取排外锁。

这个方法具体是什么意思呢？当一个 goroutine 调用这个 TryLock 方法请求锁的时候，如果这把锁没有被其他 goroutine 所持有，那么，这个 goroutine 就持有了这把锁，并返回 true；如果这把锁已经被其他 goroutine 所持有，或者是正在准备交给某个被唤醒的 goroutine，那么，这个请求锁的 goroutine 就直接返回 false，不会阻塞在方法调用上。（厕所的门锁外是不是有个红绿标志，红色表示里面有人，绿色表示里面没人，是不是一看就懂！）

如下图所示，如果 Mutex 已经被一个 goroutine 持有，调用 Lock 的 goroutine 阻塞排队等待，调用 TryLock 的 goroutine 直接得到一个 false 返回。
![TryLock图示](https://static001.geekbang.org/resource/image/e7/65/e7787d959b60d66cc3a46ee921098865.jpg)
在实际开发中，如果要更新配置数据，我们通常需要加锁，这样可以避免同时有多个 goroutine 并发修改数据。有的时候，我们也会使用 TryLock。这样一来，当某个 goroutine 想要更改配置数据时，如果发现已经有 goroutine 在更改了，其他的 goroutine 调用 TryLock，返回了 false，这个 goroutine 就会放弃更改。

那怎么实现一个扩展 TryLock 方法的 Mutex 呢？我们直接来看代码。
~~~go
package main
import (
	"fmt"
	"math/rand"
	"sync"
	"sync/atomic"
	"time"
	"unsafe"
)
// 复制Mutex定义的常量
const (
	mutexLocked = 1 << iota // 加锁标识位置
	mutexWoken              // 唤醒标识位置
	mutexStarving           // 锁饥饿标识位置
	mutexWaiterShift = iota // 标识waiter的起始bit位置
)

// 扩展一个Mutex结构
type Mutex struct {
	sync.Mutex
}

// 尝试获取锁
func (m *Mutex) TryLock() bool {
	// 如果能成功抢到锁
	if atomic.CompareAndSwapInt32((*int32)(unsafe.Pointer(&m.Mutex)), 0, mutexLocked) {
		return true
	}

	// 如果处于唤醒、加锁或者饥饿状态，这次请求就不参与竞争了，返回false
	old := atomic.LoadInt32((*int32)(unsafe.Pointer(&m.Mutex)))
	if old&(mutexLocked|mutexStarving|mutexWoken) != 0 {
		return false
	}

	// 尝试在竞争的状态下请求锁
	new := old | mutexLocked
	return atomic.CompareAndSwapInt32((*int32)(unsafe.Pointer(&m.Mutex)), old, new)
}
/*
这个测试程序的工作机制是这样子的：程序运行时会启动一个 goroutine 持有这把我们自己实现的锁，
经过随机的时间才释放。主 goroutine 会尝试获取这把锁。
如果前一个 goroutine 一秒内释放了这把锁，那么，主 goroutine
就有可能获取到这把锁了，输出“got the lock”，
否则没有获取到也不会被阻塞，会直接输出“can't get the lock”。
 */
func try() {
	var mu Mutex
	go func() { // 启动一个goroutine持有一段时间的锁
		mu.Lock()
		time.Sleep(time.Duration(rand.Intn(3)) * time.Second)
		mu.Unlock()
	}()

	time.Sleep(time.Second)

	ok := mu.TryLock() // 尝试获取到锁
	if ok { // 获取成功
		fmt.Println("got the lock")
		// do something
		mu.Unlock()

	}else {
		// 没有获取到
		fmt.Println("can't get the lock")
	}
	time.Sleep(time.Second)
	ok = mu.TryLock() // 尝试获取到锁
	if ok { // 获取成功
		fmt.Println("got the lock")
		// do something
		mu.Unlock()

	}else {
		// 没有获取到
		fmt.Println("can't get the lock")
	}

}

func main() {
	try()
}
~~~

## 获取等待者的数量等指标
在state字段中，上次有说到一个字段是设计了多个意思，通过对底层字节的切割，实现了对不同状态的显示