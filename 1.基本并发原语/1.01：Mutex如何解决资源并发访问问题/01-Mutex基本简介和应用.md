# Mutex的基本简介和应用
## 前言
并发：说白了就是系统一次运行多个程序，或者一个程序运行多个任务的过程。CPU通过切换线程对公共资源持有的时间片，去调度不同任务的异步执行。  
从程序的层面来说：就是多个线程（协程）的同时运行。运行过程中免不了对公共资源进行操作。这个公共资源可以是程序，可以是文件，可以是数据库。对于这一类的资源一般被称为**临界区**  
如果很多线程（或者协程）同步访问临界区，就会造成访问或操作错误，这当然不是我们希望看到的结果。所以，我们可以使用互斥锁，限定临界区只能同时由一个线程持有。当临界区由一个线程持有的时候，其它线程如果想进入这个临界区，就会返回失败，或者是等待。直到持有的线程退出临界区，这些等待线程中的某一个才有机会接着持有这个临界区。 
来个通俗点的解释就是上厕所大号，只有一个坑，但是这里是公共厕所，为了防止你在doing something的时候被人访问，你就会把门锁上，等到你出去了就会把门开起来，等下一个人进来。最经典的互斥锁并发理论（当然了，不能这样子对面试官讲的）
![get_lock](https://s1.ax1x.com/2020/10/13/0h8uq0.jpg "协程根据锁获取资源")  
根据上图所示互斥锁就很好地解决了资源竞争问题，有人也把互斥锁叫做排它锁。那在 Go 标准库中，它提供了 Mutex 来实现互斥锁这个功能。在很多地方也有把它叫做同步原语。go语言中的sync包就是主要负责实现这一块儿的地方。
具体什么场景适合使用同步原语呢？
- 共享资源：并发地读写共享资源，会出现数据竞争（data race）的问题，所以需要 Mutex、RWMutex 这样的并发原语来保护。
- 任务编排：需要 goroutine 按照一定的规律执行，而 goroutine 之间有相互等待或者依赖的顺序关系，我们常常使用 WaitGroup 或者 Channel 来实现。
- 消息传递：信息交流以及不同的 goroutine 之间的线程安全的数据交流，常常使用 Channel 来实现。
接下来从互斥锁开始说。
## Mutex 的基本使用方法
在go语言的sync包中Mutex实现了Locker接口，我们来先看下Locker接口的代码
``` go
// A Locker represents an object that can be locked and unlocked.
type Locker interface {
	Lock()
	Unlock()
}
```
可以看到，Go 定义的锁接口的方法集很简单，就是请求锁（Lock）和释放锁（Unlock）这两个方法，秉承了 Go 语言一贯的简洁风格。
但是我们一般会直接使用具体的同步原语，而不是通过接口。
接下来我们直接看Mutex：**互斥锁 Mutex 就提供两个方法 Lock 和 Unlock：进入临界区之前调用 Lock 方法，退出临界区的时候调用 Unlock 方法：**
``` go
// A Locker represents an object that can be locked and unlocked.
  func(m *Mutex)Lock()
  func(m *Mutex)Unlock()
```
**当一个 goroutine 通过调用 Lock 方法获得了这个锁的拥有权后， 其它请求锁的 goroutine 就会阻塞在 Lock 方法的调用上，直到锁被释放并且自己获取到了这个锁的拥有权。**（跟上述是不是很像，doing something）

