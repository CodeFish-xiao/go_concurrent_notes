# Mutex的基本简介和应用
## 前言
并发：说白了就是系统一次运行多个程序，或者一个程序运行多个任务的过程。CPU通过切换线程对公共资源持有的时间片，去调度不同任务的异步执行。  
从程序的层面来说：就是多个线程（协程）的同时运行。运行过程中免不了对公共资源进行操作。这个公共资源可以是程序，可以是文件，可以是数据库。对于这一类的资源一般被称为**临界区**  
如果很多线程（或者协程）同步访问临界区，就会造成访问或操作错误，这当然不是我们希望看到的结果。所以，我们可以使用互斥锁，限定临界区只能同时由一个线程持有。当临界区由一个线程持有的时候，其它线程如果想进入这个临界区，就会返回失败，或者是等待。直到持有的线程退出临界区，这些等待线程中的某一个才有机会接着持有这个临界区。 
来个通俗点的解释就是上厕所大号，只有一个坑，但是这里是公共厕所，为了防止你在doing something的时候被人访问，你就会把门锁上，等到你出去了就会把门开起来，等下一个人进来。最经典的互斥锁并发理论（当然了，不能这样子对面试官讲的）
![get_lock](https://s1.ax1x.com/2020/10/13/0h8uq0.jpg "协程根据锁获取资源")  
根据上图所示互斥锁就很好地解决了资源竞争问题，有人也把互斥锁叫做排它锁。那在 Go 标准库中，它提供了 Mutex 来实现互斥锁这个功能。在很多地方也有把它叫做同步原语。go语言中的sync包就是主要负责实现这一块儿的地方。
具体什么场景适合使用同步原语呢？
- 共享资源：并发地读写共享资源，会出现数据竞争（data race）的问题，所以需要 Mutex、RWMutex 这样的并发原语来保护。
- 任务编排：需要 goroutine 按照一定的规律执行，而 goroutine 之间有相互等待或者依赖的顺序关系，我们常常使用 WaitGroup 或者 Channel 来实现。
- 消息传递：信息交流以及不同的 goroutine 之间的线程安全的数据交流，常常使用 Channel 来实现。
接下来从互斥锁开始说。
## Mutex 的基本使用方法
在go语言的sync包中Mutex实现了Locker接口，我们来先看下Locker接口的代码
``` go
// A Locker represents an object that can be locked and unlocked.
type Locker interface {
	Lock()
	Unlock()
}
```
可以看到，Go 定义的锁接口的方法集很简单，就是请求锁（Lock）和释放锁（Unlock）这两个方法，秉承了 Go 语言一贯的简洁风格。
但是我们一般会直接使用具体的同步原语，而不是通过接口。
接下来我们直接看Mutex：**互斥锁 Mutex 就提供两个方法 Lock 和 Unlock：进入临界区之前调用 Lock 方法，退出临界区的时候调用 Unlock 方法：**
``` go
// A Locker represents an object that can be locked and unlocked.
  func(m *Mutex)Lock()
  func(m *Mutex)Unlock()
```
**当一个 goroutine 通过调用 Lock 方法获得了这个锁的拥有权后， 其它请求锁的 goroutine 就会阻塞在 Lock 方法的调用上，直到锁被释放并且自己获取到了这个锁的拥有权。**（跟上述是不是很像，doing something）  
至于为什么要加锁，以i++来说，线程在处理这一个的时候，会先从内存复制一个值，取完了进行加一放回去，你放的快别人拿的时候看到的就是你改过的值，你放的慢你就把别人的值给覆盖了。
举个例子吧：
``` go
package main

import (
	"fmt"
	"sync"
)

func main() {
	for i := 0; i < 10; i++ {//简单for循环
		fmt.Printf("第%d次输出: ",i)
		UnLock()
	}

}

func UnLock() {
	var count = 0
	// 使用WaitGroup等待10个goroutine完成
	var wg sync.WaitGroup
	wg.Add(10)
	for i := 0; i < 10; i++ {
		go func() {
			defer wg.Done()
			// 对变量count执行10次加1
			for j := 0; j < 100000; j++ {
				count++
			}
		}()
	}
	// 等待10个goroutine完成
	wg.Wait()
	fmt.Println(count)
}

```
在unLock函数中，10个协程同时对一个进行 10 万次的加 1 操作，我们期望的最后计数的结果是 10 * 100000 = 1000000 (一百万)。但是实际的结果确实这样的：  

![运行结果](https://s1.ax1x.com/2020/10/14/05TCjO.png "未加锁的运行结果")  
10次的输出都没有一次是正确答案，可见没有加锁的并发读写是多么的不安全。这个问题，有经验的开发人员还是比较容易发现的，但是，很多时候，并发问题隐藏得非常深，即使是有经验的人，也不太容易发现或者 Debug 出来。针对这个问题，Go 提供了一个检测并发访问共享资源是否有问题的工具： race detector，它可以帮助我们自动发现程序有没有 data race 的问题。  
Go race detector 是基于 Google 的 C/C++ sanitizers 技术实现的，编译器通过探测所有的内存访问，加入代码能监视对这些内存地址的访问（读还是写）。在代码运行的时候，race detector 就能监控到对共享变量的非同步访问，出现 race 的时候，就会打印出警告信息。例如：go run -race counter.go  
既然这个例子存在 data race 问题，我们就要想办法来解决它。这个时候，我们的主角 Mutex 就要登场了，它可以轻松地消除掉 data race。
